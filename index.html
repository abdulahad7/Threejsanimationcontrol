<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="viewport" content="width=device-width, initial-scale=1.0">
  <title>Three.js Character Animation with Object Holding Options</title>
  <style>
    body { margin: 0; }
    canvas { display: block; }
  </style>
</head>
<body>
  <!-- Import map for Three.js modules -->
  <script type="importmap">
    {
      "imports": {
        "three": "./build/three.module.js",
        "three/addons/": "./jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

    // Scene Setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xffffff);

    // Camera Setup
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 2, 5);

    // Renderer Setup
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Orbit Controls for camera zoom and rotation
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 1, 0);
    controls.update();

    // Lighting Setup
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(5, 5, 5);
    scene.add(directionalLight);

    // Grid Helper
    const gridHelper = new THREE.GridHelper(20, 40);
    scene.add(gridHelper);

    // Make the canvas focusable
    const canvas = renderer.domElement;
    canvas.tabIndex = 0; // Allow the canvas to be focusable
    canvas.focus(); // Focus the canvas initially

    // Refocus Canvas After GUI Interaction
    document.addEventListener('mousedown', (event) => {
      if (event.target.closest('.lil-gui')) {
        setTimeout(() => canvas.focus(), 0); // Delay to ensure GUI processes the click
      }
    });

    const clock = new THREE.Clock();
    let mixer, model, characterControls;
    const actions = new Map();
    let activeAction = null, previousAction = null;
    let gui;
    const api = { State: 'Idle', equipment: 'None' };

    const loader = new GLTFLoader();

    // Load model and animations
    loader.load('animations/ALS_N_Idle.glb', (gltf) => {
      model = gltf.scene;
      scene.add(model);

      // Initialize the animation mixer
      mixer = new THREE.AnimationMixer(model);

      // Load Idle animation
      const idleAction = mixer.clipAction(gltf.animations[0]);
      actions.set('Idle', idleAction);

      // Load Walking animation
      loader.load('animations/ALS_N_Walk_F.glb', (gltf) => {
        const walkAction = mixer.clipAction(gltf.animations[0]);
        actions.set('Walking', walkAction);
      });

      // Load Sprinting animation
      loader.load('animations/ALS_N_Sprint.glb', (gltf) => {
        const sprintAction = mixer.clipAction(gltf.animations[0]);
        sprintAction.setEffectiveTimeScale(1.2);
        actions.set('Sprinting', sprintAction);
      });

      // Load Jumping animation
      loader.load('animations/ALS_N_Jump.glb', (gltf) => {
        const jumpAction = mixer.clipAction(gltf.animations[0]);
        actions.set('Jump', jumpAction);
        actions.get('Jump').setLoop(THREE.LoopOnce);
        actions.get('Jump').clampWhenFinished = true;
      });

      // Load additional animations for GUI
      loadAdditionalAnimations();

      console.log('Animations loaded successfully');
      createCharacterControls(); 
    });

    function loadAdditionalAnimations() {
      // Load animations for holding objects
      loader.load('animations/ALS_Props_M4A1.glb', (gltf) => {
        const rifleAction = mixer.clipAction(gltf.animations[0]);
        if (rifleAction) {
          rifleAction.loop = THREE.LoopRepeat;
          rifleAction.enabled = true;
          actions.set('Has Rifle', rifleAction);
          console.log('Rifle animation loaded');
        } else {
          console.warn('Rifle animation failed to load');
        }
      });

      loader.load('animations/ALS_Props_Box.glb', (gltf) => {
        const boxAction = mixer.clipAction(gltf.animations[0]);
        if (boxAction) {
          boxAction.loop = THREE.LoopRepeat;
          boxAction.enabled = true;
          actions.set('Has Box', boxAction);
          console.log('Box animation loaded');
        } else {
          console.warn('Box animation failed to load');
        }
      });

      loader.load('animations/ALS_Props_Barrel.glb', (gltf) => {
        const barrelAction = mixer.clipAction(gltf.animations[0]);
        if (barrelAction) {
          barrelAction.loop = THREE.LoopRepeat;
          barrelAction.enabled = true;
          actions.set('Has Barrel', barrelAction);
          console.log('Barrel animation loaded');
        } else {
          console.warn('Barrel animation failed to load');
        }
      });
    }

    function handleEquipmentChange(selectedOption) {
      if (selectedOption === 'None') {
        characterControls.stopAllAnimations();
        characterControls.fadeToAction('Idle', 0.5);
        return;
      }

      if (characterControls) {
        characterControls.stopAllAnimations(true);
        const equipmentAction = actions.get(selectedOption);

        if (!equipmentAction) {
          console.warn(`Equipment animation "${selectedOption}" not found!`);
          return;
        }

        const lowerBodyMask = createLowerBodyMask(characterControls.model);
        applyLowerBodyAnimation(equipmentAction, lowerBodyMask);

        equipmentAction.reset()
          .setEffectiveTimeScale(1)
          .setEffectiveWeight(1)
          .fadeIn(0.5)
          .play();

        const checkEquipmentState = setInterval(() => {
          if (api[selectedOption] === true) {
            if (!equipmentAction.isRunning()) {
              equipmentAction.reset().play();
            }
          } else {
            equipmentAction.fadeOut(0.5);
            clearInterval(checkEquipmentState);
          }
        }, 100);
      }
    }

    function createCharacterControls() {
      characterControls = new CharacterControls(model, mixer, actions, controls, camera, 'Idle');
      createGUI(); 
      animate();
    }

    function createGUI() {
      const emotes = ['Jump'];

      gui = new GUI(); 

      const emoteFolder = gui.addFolder('Emotes');
      emotes.forEach((name) => {
        api[name] = function () {
          if (characterControls) {
            characterControls.jumpForward();
          }
        };
        emoteFolder.add(api, name);
      });

      emoteFolder.open();

      const equipmentFolder = gui.addFolder('Equipment');
      const equipmentOptions = ['None', 'Has Rifle', 'Has Box', 'Has Barrel'];

      equipmentOptions.forEach((option) => {
        api[option] = false;

        const checkboxCtrl = equipmentFolder.add(api, option).name(option).listen();

        checkboxCtrl.onChange(() => handleCheckboxChange(option));
      });

      equipmentFolder.open();
    }

    function handleCheckboxChange(selectedOption) {
      Object.keys(api).forEach((key) => {
        if (key === 'None' || key === 'Has Rifle' || key === 'Has Box' || key === 'Has Barrel') {
          api[key] = false;
        }
      });

      api[selectedOption] = true;
      handleEquipmentChange(selectedOption);
    }

    // Key Press Handling
    const keysPressed = {};
    window.addEventListener('keydown', (event) => {
      const key = event.key.toLowerCase();
      keysPressed[key] = true;

      // Trigger the jump animation if the spacebar is pressed
      if (key === ' ') {
        if (characterControls) {
          characterControls.jumpForward();
        }
      }
    });

    window.addEventListener('keyup', (event) => {
      keysPressed[event.key.toLowerCase()] = false;
    });

    function createLowerBodyMask(model) {
      const mask = new Set();
      const lowerBodyBones = ['hips', 'leftUpLeg', 'rightUpLeg', 'leftLeg', 'rightLeg', 'leftFoot', 'rightFoot'];

      model.traverse((object) => {
        if (object.isBone && lowerBodyBones.includes(object.name)) {
          mask.add(object.uuid);
        }
      });

      return mask;
    }

    function applyLowerBodyAnimation(action, mask) {
      action.setEffectiveWeight(1);

      action.getMixer().addEventListener('loop', (event) => {
        if (event.action === action) {
          action.getRoot().traverse((object) => {
            if (object.isBone) {
              object.animations.forEach((track) => {
                if (!mask.has(track.uuid)) {
                  track.setEffectiveWeight(0);
                }
              });
            }
          });
        }
      });
    }

    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      if (characterControls) characterControls.update(delta, keysPressed);
      renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    class CharacterControls {
      constructor(model, mixer, animationsMap, orbitControl, camera, currentAction) {
        this.model = model;
        this.mixer = mixer;
        this.animationsMap = animationsMap;
        this.currentAction = currentAction;
        this.animationsMap.forEach((value, key) => {
          if (key === currentAction) {
            value.play();
          }
        });
        this.orbitControls = orbitControl;
        this.camera = camera;

        this.walkDirection = new THREE.Vector3();
        this.rotateAngle = new THREE.Vector3(0, 1, 0);
        this.rotateQuaternion = new THREE.Quaternion();
        this.cameraTarget = new THREE.Vector3();

        this.toggleRun = false;
        this.fadeDuration = 0.2;
        this.walkVelocity = 2;
        this.runVelocity = 4;
        this.jumpVelocity = 0.1;
        this.updateCameraTarget(0, 0);
      }

      fadeToAction(name, duration) {
        const previousAction = this.animationsMap.get(this.currentAction);
        const activeAction = this.animationsMap.get(name);

        if (!activeAction) {
          console.warn(`Animation "${name}" not found!`);
          return;
        }

        if (previousAction && previousAction !== activeAction) {
          previousAction.fadeOut(duration);
        }

        activeAction
          .reset()
          .setEffectiveTimeScale(1)
          .setEffectiveWeight(1)
          .fadeIn(duration)
          .play();

        this.currentAction = name;
      }

      isEquipmentAnimation(action) {
        const equipmentActions = ['Has Rifle', 'Has Box', 'Has Barrel'];
        return equipmentActions.includes(action._clip.name);
      }

      stopAllAnimations(preserveMovement = false) {
        this.animationsMap.forEach((action, key) => {
          if (preserveMovement && (key === 'Walking' || key === 'Sprinting' || key === 'Idle')) {
            return;
          }
          action.fadeOut(0.2);
        });
      }

      jumpForward() {
        const directionPressed = ["w", "a", "s", "d"].some((key) => keysPressed[key] === true);

        const jumpAction = this.animationsMap.get('Jump');
        const currentAction = this.animationsMap.get(this.currentAction);

        console.log(`Before Jump: Current Animation - ${this.currentAction}`);

        jumpAction.reset()
          .setEffectiveTimeScale(0.5)
          .setEffectiveWeight(1)
          .crossFadeFrom(currentAction, 0.3, true)
          .play();

        jumpAction.setLoop(THREE.LoopOnce);
        jumpAction.clampWhenFinished = true;

        const jumpHeight = 1;
        const jumpDuration = 1;
        const startTime = performance.now();

        const onJumpFinished = (event) => {
          if (event.action === jumpAction) {
            mixer.removeEventListener('finished', onJumpFinished);
            console.log('Jump Finished: Transitioning to Idle State');
            this.model.position.y = 0;
            this.fadeOutAllAnimations(0.5);
          }
        };

        mixer.addEventListener('finished', onJumpFinished);

        const smoothJump = () => {
          const elapsedTime = (performance.now() - startTime) / 1000;
          const progress = elapsedTime / jumpDuration;

          if (progress < 1) {
            const yOffset = jumpHeight * Math.sin(Math.PI * progress);
            this.model.position.y = yOffset;

            requestAnimationFrame(smoothJump);
          } else {
            this.model.position.y = 0;
          }
        };

        smoothJump();
      }

      fadeOutAllAnimations(duration) {
        this.animationsMap.forEach((action) => {
          action.fadeOut(duration);
        });

        setTimeout(() => {
          this.fadeToAction('Idle', duration);
        }, duration * 1000);
      }

      update(delta, keysPressed) {
        const shiftPressed = keysPressed['shift'];
        const directionPressed = ["w", "a", "s", "d"].some((key) => keysPressed[key] === true);
        let play = "";

        const equipmentSelected = api['Has Rifle'] || api['Has Box'] || api['Has Barrel'];

        if (directionPressed && equipmentSelected) {
          play = shiftPressed ? "Sprinting" : "Walking";
          this.walkVelocity = shiftPressed ? this.runVelocity * 2 : 2;
        } else if (directionPressed && shiftPressed) {
          play = "Sprinting";
          this.walkVelocity = this.runVelocity * 2;
        } else if (directionPressed) {
          play = "Walking";
          this.walkVelocity = 2;
        } else {
          play = "Idle";
          api.State = "Idle";
        }

        if (this.currentAction !== play && !this.isEquipmentAnimation(this.animationsMap.get(play))) {
          this.fadeToAction(play, this.fadeDuration);
        }

        this.mixer.update(delta);

        if (directionPressed) {
          const angleYCameraDirection = Math.atan2(
            this.camera.position.x - this.model.position.x,
            this.camera.position.z - this.model.position.z
          );

          const directionOffset = this.directionOffset(keysPressed);

          this.rotateQuaternion.setFromAxisAngle(
            this.rotateAngle,
            angleYCameraDirection + directionOffset
          );

          this.model.quaternion.rotateTowards(this.rotateQuaternion, 0.2);

          this.camera.getWorldDirection(this.walkDirection);
          this.walkDirection.negate();
          this.walkDirection.y = 0;
          this.walkDirection.normalize();
          this.walkDirection.applyAxisAngle(this.rotateAngle, directionOffset);

          const moveX = this.walkDirection.x * this.walkVelocity * delta;
          const moveZ = this.walkDirection.z * this.walkVelocity * delta;
          this.model.position.x += moveX;
          this.model.position.z += moveZ;

          this.updateCameraTarget(moveX, moveZ);
        }
      }

      updateCameraTarget(moveX, moveZ) {
        this.camera.position.x += moveX;
        this.camera.position.z += moveZ;

        this.cameraTarget.x = this.model.position.x;
        this.cameraTarget.y = this.model.position.y + 1;
        this.cameraTarget.z = this.model.position.z;
        this.orbitControls.target = this.cameraTarget;
      }

      directionOffset(keysPressed) {
        let directionOffset = 0;

        if (keysPressed["s"]) {
          if (keysPressed["d"]) {
            directionOffset = Math.PI / 4;
          } else if (keysPressed["a"]) {
            directionOffset = -Math.PI / 4;
          } else {
            directionOffset = 0;
          }
        } else if (keysPressed["w"]) {
          if (keysPressed["d"]) {
            directionOffset = Math.PI - Math.PI / 4;
          } else if (keysPressed["a"]) {
            directionOffset = -(Math.PI - Math.PI / 4);
          } else {
            directionOffset = Math.PI;
          }
        } else if (keysPressed["d"]) {
          if (keysPressed["w"]) {
            directionOffset = -Math.PI / 4;
          } else if (keysPressed["s"]) {
            directionOffset = Math.PI / 4;
          } else {
            directionOffset = Math.PI / 2;
          }
        } else if (keysPressed["a"]) {
          if (keysPressed["w"]) {
            directionOffset = Math.PI - Math.PI / 4;
          } else if (keysPressed["s"]) {
            directionOffset = -(Math.PI - Math.PI / 4);
          } else {
            directionOffset = -Math.PI / 2;
          }
        }

        return directionOffset;
      }
    }
  </script>
</body>
</html>
